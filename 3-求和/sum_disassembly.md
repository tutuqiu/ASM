SUM.out:  file format mach-o arm64

Disassembly of section __TEXT,__text:

0000000100000460 <_main>:
100000460: d100c3ff     sub   sp, sp, #0x30         // 为 main 分配 0x30=48 字节栈空间
100000464: a9027bfd     stp   x29, x30, [sp, #0x20] // 保存旧帧指针 x29 和返回地址 x30
100000468: 910083fd     add   x29, sp, #0x20        // 建立新的栈帧

; 局部变量初始化：
; [x29-4]  可能是一个未用的局部，清零；
; [x29-0xc] 为 sum，清零。
10000046c: b81fc3bf     stur  wzr, [x29, #-0x4]     // 写 0 到 [x29-4]
100000470: b81f43bf     stur  wzr, [x29, #-0xc]     // sum = 0

; ----------- 第一次调用：输出提示 / 读取格式串（具体取决于 C 源代码）-----------
100000474: 90000000     adrp  x0, 0x100000000       // x0 = 某个字符串所在的页
100000478: 91147000     add   x0, x0, #0x51c        // x0 = 字符串1（可能是提示："Input n:"）
10000047c: 94000022     bl    0x100000504           // 调用库函数（printf 或 puts）

; ----------- 第二次调用：scanf("%d",&n) -----------
100000480: 910003e9     mov   x9, sp                // x9 = sp
100000484: d10023a8     sub   x8, x29, #0x8         // x8 = x29 - 8，作为变量 n 的地址
100000488: f9000128     str   x8, [x9]              // *(sp) = &n，准备参数 &n

10000048c: 90000000     adrp  x0, 0x100000000       // x0 = 格式串所在页
100000490: 9114b000     add   x0, x0, #0x52c        // x0 = "%d" 或类似格式串
100000494: 9400001f     bl    0x100000510           // 调用 scanf("%d", &n)

; ----------- i = 1; （循环变量从 1 开始）-----------
100000498: 52800028     mov   w8, #0x1              // w8 = 1
10000049c: b90013e8     str   w8, [sp, #0x10]       // [sp+0x10] = i

; 跳到 for/while 循环条件判断
1000004a0: 14000001     b     0x1000004a4

; 循环条件：while (i <= n)
1000004a4: b94013e8     ldr   w8, [sp, #0x10]       // w8 = i
1000004a8: b85f83a9     ldur  w9, [x29, #-0x8]      // w9 = n
1000004ac: 6b090108     subs  w8, w8, w9           // i - n
1000004b0: 5400016c     b.gt  0x1000004dc           // i > n 时退出循环

; 循环体：sum += i;
1000004b4: 14000001     b     0x1000004b8
1000004b8: b94013e9     ldr   w9, [sp, #0x10]       // w9 = i
1000004bc: b85f43a8     ldur  w8, [x29, #-0xc]      // w8 = sum
1000004c0: 0b090108     add   w8, w8, w9           // w8 = sum + i
1000004c4: b81f43a8     stur  w8, [x29, #-0xc]      // sum = sum + i

; i++
1000004c8: 14000001     b     0x1000004cc
1000004cc: b94013e8     ldr   w8, [sp, #0x10]       // w8 = i
1000004d0: 11000508     add   w8, w8, #0x1          // i + 1
1000004d4: b90013e8     str   w8, [sp, #0x10]       // i = i + 1
1000004d8: 17fffff3     b     0x1000004a4           // 回到循环条件判断

; 循环结束：打印结果 sum
1000004dc: b85f43a8     ldur  w8, [x29, #-0xc]      // w8 = sum
1000004e0: 910003e9     mov   x9, sp                // x9 = sp
1000004e4: f9000128     str   x8, [x9]              // *(sp) = sum  作为参数

1000004e8: 90000000     adrp  x0, 0x100000000       // x0 = 结果格式串所在页
1000004ec: 9114bc00     add   x0, x0, #0x52f        // x0 = "sum=%d\n" 之类的字符串
1000004f0: 94000005     bl    0x100000504           // 调用 printf/puts 打印 sum

; return 0;
1000004f4: 52800000     mov   w0, #0x0              // 返回值 = 0

; 恢复栈帧并返回
1000004f8: a9427bfd     ldp   x29, x30, [sp, #0x20] // 恢复 x29、x30
1000004fc: 9100c3ff     add   sp, sp, #0x30         // 释放栈空间
100000500: d65f03c0     ret                         // 从 main 返回

Disassembly of section __TEXT,__stubs:

0000000100000504 <__stubs>:
100000504: 90000030     adrp  x16, 0x100004000      // 下面两个是 PLT/GOT 跳板
100000508: f9400210     ldr   x16, [x16]           // 取出某库函数实际地址（printf/puts）
10000050c: d61f0200     br    x16

100000510: 90000030     adrp  x16, 0x100004000      // 第二个跳板，用于 scanf
100000514: f9400610     ldr   x16, [x16, #0x8]     // 取出 scanf 实际地址
100000518: d61f0200     br    x16
