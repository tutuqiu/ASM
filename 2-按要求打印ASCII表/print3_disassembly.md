# ARM64 反汇编注释 —— `print3`

---

## 概述（程序在做什么）

程序打印小写字母 `a..z`，分 **两行** 输出，每行 **13 个字符**；每行末尾输出 **回车 CR** 与 **换行 LF**（先 `'\r'` 再 `'\n'`）。

整体流程：
- 定义每行个数 `13`、行数 `2`，起始字符为 `'a'`；
- 外层循环按“行”进行两次；
- 内层循环按“列”进行 13 次，每次输出当前字符并自增；
- 每行结束后输出 CR 与 LF；
- 全部结束返回 0。

---

## AArch64 寄存器与调用约定速记

- `xN` 为 64 位通用寄存器，`wN` 为对应低 32 位视图。
- `sp` 为栈指针，栈空间向**低地址**增长。
- `x29` 通常作为帧指针（FP），`x30` 为返回地址寄存器（LR）。
- `xzr/wzr` 为**零寄存器**：读恒为 0，写会被丢弃。
- C 调用约定中：第一个整型/指针实参放在 `w0/x0`。

---

## 栈帧与局部变量布局（相对帧指针 `x29`）

- 进入 `main`：先在栈上申请 48 字节空间；保存旧的 `x29/x30`；令 `x29 = sp + 0x20` 作为当前帧指针。
- 变量位置：
  - `[x29-0x08]`：`perline`（int）= 13  
  - `[x29-0x0C]`：`lines`（int）= 2  
  - `[x29-0x0D]`：`ch`（char）= `'a'`  
  - `[sp+0x08]`：`c`（内层列计数，int）  
  - `[sp+0x0C]`：`r`（外层行计数，int）  
- 编译器还写了 `*(int*)(x29-4)=0`（用于对齐/占位），对逻辑无实质影响。

---

## 逐条反汇编注释（中文）

**函数入口与栈帧建立**
```
sub sp, sp, #0x30              ; 在栈上预留 48 字节
stp x29, x30, [sp, #0x20]      ; 保存旧的帧指针/返回地址
add x29, sp, #0x20             ; 建立新的帧指针 x29
```

**初始化局部变量**
```
stur wzr, [x29, #-0x4]         ; *(x29-4)=0（对齐/占位）
mov  w8, #13                   ; perline = 13
stur w8, [x29, #-0x8]
mov  w8, #2                    ; lines = 2
stur w8, [x29, #-0xC]
mov  w8, #97                   ; 'a'
sturb w8, [x29, #-0xD]         ; ch = 'a'
```

**外层循环：r 从 0 到 1**
```
str  wzr, [sp, #0xC]           ; r = 0
b    <检查 r<2>                ; 跳到条件检查

<检查 r<2>:
ldr  w8, [sp, #0xC]            ; w8 = r
subs w8, w8, #2                ; 计算 r-2，设置标志位
b.ge <外层收尾>                ; r>=2 则退出外层
```

**内层循环：c 从 0 到 12**
```
str  wzr, [sp, #0x8]           ; c = 0
b    <检查 c<13>               ; 跳到条件检查

<检查 c<13>:
ldr  w8, [sp, #0x8]            ; w8 = c
subs w8, w8, #13               ; 计算 c-13
b.ge <本行结束>                ; c>=13 则跳出内层
```

**内层循环体：输出并自增字符**
```
ldursb w0, [x29, #-0xD]        ; w0 = ch（作为 putchar 的第 1 个参数）
add    w8, w0, #1              ; w8 = ch + 1
sturb  w8, [x29, #-0xD]        ; ch = ch + 1（后缀自增语义：先用后加）
bl     <putchar 桩>            ; 调用 putchar(ch)

ldr  w8, [sp, #0x8]            ; w8 = c
add  w8, w8, #1                ; c++
str  w8, [sp, #0x8]
b    <检查 c<13>               ; 回到内层判断
```

**一行结束：输出 CR 与 LF**
```
mov  w0, #13                   ; '\r'（CR）
bl   <putchar 桩>
mov  w0, #10                   ; '\n'（LF）
bl   <putchar 桩>
```

**外层自增并循环**
```
ldr  w8, [sp, #0xC]            ; w8 = r
add  w8, w8, #1                ; r++
str  w8, [sp, #0xC]
b    <检查 r<2>                ; 回到外层判断
```

**函数返回**
```
mov  w0, #0                    ; 返回值 0
ldp  x29, x30, [sp, #0x20]     ; 恢复帧指针/返回地址
add  sp, sp, #0x30             ; 释放栈空间
ret                            ; 返回调用者
```

---

## `__stubs`（动态链接跳板，供 `putchar` 使用）

```
adrp x16, <GOT 基址页>         ; 取到全局偏移表所在页
ldr  x16, [x16]                ; 取出真实 putchar 地址（可能延迟绑定）
br   x16                       ; 无条件跳转到真实函数
```
说明：这是一段由动态链接器使用的**桩代码**。首次调用时可能触发符号解析，之后会直接跳到已解析的 `putchar` 地址。

---

## 关键点总结

- 外层循环控制“行数”，内层循环控制“每行字符数”。
- 字符 `ch` 作为**1 字节局部变量**存储在 `[x29-0x0D]`，每次输出后自增，保证第二行从 `'n'` 继续到 `'z'`。
- `putchar(ch++)` 的“后缀自增”体现为：先把旧值放入 `w0` 作为实参，再把 `ch` 写回为 `ch+1`。
- 换行采用先 **CR** 后 **LF** 的顺序（`'\r'` → `'\n'`）。
- 函数遵循 AArch64 调用约定，使用标准的栈帧建立与恢复。

---

## 输出示例（两行）
```
abcdefghijklm
nopqrstuvwxyz
```
